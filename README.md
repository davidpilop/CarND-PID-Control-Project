# PID controller
[![Udacity - Self-Driving Car NanoDegree](https://s3.amazonaws.com/udacity-sdc/github/shield-carnd.svg)](http://www.udacity.com/drive)

## Directories
The directory structure of this project is as follows:

```
root
|   CMakeLists.txt
|   README.md
|   
|___src
    |   json.hpp
    |   main.cpp
    |   PID.cpp
    |   PID.h
```

## Project Instructions

The objective of this project is the implementation of a PID controller in C++ to maneuver the vehicle around the track.

The simulator provides the cross track error (CTE) and the velocity (mph) in order to compute the appropriate steering angle.

## Theoretical concepts

A *proportional–integral–derivative controller* (**PID controller**) continuously calculates an *error value* **e(t)** as the difference between a desired setpoint (*SP*) and a measured process variable (*PV*) and applies a correction based on proportional, integral, and derivative terms.

### Fundamental operation

The distinguishing feature of the *PID controller* is the ability to use the three control terms of proportional, integral and derivative influence on the controller output to apply accurate and optimal control.

![PID_diagram](./PID_diagram.png)

The block diagram shows the principles of how these terms are generated and applied. It shows a PID controller which continuously calculates an error value **e(t)** as the difference between a desired setpoint **SP = r(t)** and a measured process variable **PV = y(t)**, and applies a correction based on proportional, integral, and derivative terms. The controller attempts to minimize the error over time by adjustment of a control variable **u(t)**, such as the opening of a control valve, to a new value determined by a weighted sum of the control terms.

* *Term P* is proportional to the current value of the SP-PV error e(t).
* *Term I* accounts for past values of the SP-PV error and integrates them over time to produce the I term. If there is a residual SP-PV error after the application of proportional control, the integral term seeks to eliminate the residual error by adding a control effect due to the historic cumulative value of the error. When the error is eliminated, the integral term will cease to grow. This will result in the proportional effect diminishing as the error decreases, but this is compensated for by the growing integral effect.
* *Term D* is a best estimate of the future trend of the SP-PV error, based on its current rate of change. It is sometimes called "anticipatory control" as it is effectively seeking to reduce the effect of the SP-PV error by exerting a control influence generated by the rate of error change. The more rapid the change, the greater the controlling or dampening effect.

### Tuning

The balance of these effects is achieved by "loop tuning" to produce the optimal control function. The tuning constants are shown as "K" and must be derived for each control application, as they depend on the response characteristics of the complete loop external to the controller. These are dependent on the behaviour of the measuring sensor, the final control element (such as a control valve), any control signal delays and the process itself. Approximate values of constants can usually be initially entered knowing the type of application, but they are normally refined, or tuned, by "bumping" the process in practice by such as introducing a setpoint change and observing the system response.

### Implementation

I have divided the project into two parts. On the one hand I made the implementation of the PID Controller, and on the other hand I made the implementation of the Twiddle algorithm for the tuning of the parameters. Depending on the value we assign to 'TWIDDLE' we can implement an algorithm or another

```
#define TWIDDLE false
```

In case TWIDDLE is false, we initialize the parameters to specific values and only have to update the error and calculate the steering angle. However, if TWIDDLE is true, we will call the Twiddle function, which is composed of a two-state state machine.

---

## Dependencies

* cmake >= 3.5
 * All OSes: [click here for installation instructions](https://cmake.org/install/)
* make >= 4.1(mac, linux), 3.81(Windows)
  * Linux: make is installed by default on most Linux distros
  * Mac: [install Xcode command line tools to get make](https://developer.apple.com/xcode/features/)
  * Windows: [Click here for installation instructions](http://gnuwin32.sourceforge.net/packages/make.htm)
* gcc/g++ >= 5.4
  * Linux: gcc / g++ is installed by default on most Linux distros
  * Mac: same deal as make - [install Xcode command line tools]((https://developer.apple.com/xcode/features/)
  * Windows: recommend using [MinGW](http://www.mingw.org/)
* [uWebSockets](https://github.com/uWebSockets/uWebSockets)
  * Run either `./install-mac.sh` or `./install-ubuntu.sh`.
  * If you install from source, checkout to commit `e94b6e1`, i.e.
    ```
    git clone https://github.com/uWebSockets/uWebSockets
    cd uWebSockets
    git checkout e94b6e1
    ```
    Some function signatures have changed in v0.14.x. See [this PR](https://github.com/udacity/CarND-MPC-Project/pull/3) for more details.
* Simulator. You can download these from the [project intro page](https://github.com/udacity/self-driving-car-sim/releases) in the classroom.

There's an experimental patch for windows in this [PR](https://github.com/udacity/CarND-PID-Control-Project/pull/3)

## Basic Build Instructions

1. Clone this repo.
2. Make a build directory: `mkdir build && cd build`
3. Compile: `cmake .. && make`
4. Run it: `./pid`.

Tips for setting up your environment can be found [here](https://classroom.udacity.com/nanodegrees/nd013/parts/40f38239-66b6-46ec-ae68-03afd8a601c8/modules/0949fca6-b379-42af-a919-ee50aa304e6a/lessons/f758c44c-5e40-4e01-93b5-1a82aa4e044f/concepts/23d376c7-0195-4276-bdf0-e02f1f3c665d)
